# HybridSearch

This project develops a concurrent filtering technique that speeds up hybrid search, which can be thought as a vector similarity search with additional scalar attribute filtering.

A brief introduction to Hybrid Search is available on https://milvus.io/docs/hybridsearch.md.
Traditionally, there have been 2 approaches to do hybrid search: pre-query filtering, which means entries are filtered before the index is built, and post-query filtering, which means entries are filtered after similarity search is complete. Both methods com with drawbacks. While pre-query filtering is inflexible against the change of filtering criteria which results in rebuilding the index, the number of results obtained from post-query filtering is not precise as the filtering outcome on similarity search results can only be estimated.

We propose a new technique, namely concurrent filtering, which aims at solving the above problems and improving computational performance at the same time. Instead of filtering before or after the vector search, we filter results during the search. This means that a full index is built as in post-query filtering, but the queries into the index contain information about the filtering criteria. If a point is invalid for the purpose of filtering, then the searching algorithm does not include it in the result list, which allows for larger flexibility in the remaining process. Implementations of concurrent filtering on VP Tree and NSW are provided. Experiment results indicate that it outperforms post-query filtering in both computation time and achieving exact number of results, and might be a better option than pre-query filtering when flexibility in the filtering criteria is needed.

Although not quite compatible with hashing-based kNN algorithms, concurrent filtering can be applied to most graph-based and partition-based ones because it is independent to the specific graph / tree structure. Therefore, we show its performance on VP-Tree and NSW, which are representatives from each category, to demonstrate its effects on hybrid searching in general.

Here is some more detailed explanation:

For both VP-Tree and NSW, pre-query filtering means only those data points that pass the scalar filtering criteria are fed into the index-building algorithm, and a similarity search is conducted on a reduced index. Post-query filtering means that conventional similarity search is conducted on a full index of all data points, and a list of heterogeneous results is returned. Attribute filtering is then applied to extract the desired responses. Concurrent filtering is a little different in the two scenarios, but it keeps the same idea which is to filter the result on the search path.

A normal similarity search on VP-Tree given query point P and distance threshold d begins from a parent node. If the parent node containing point Q is within the threshold, then Q is added to the result list. Then, depending on the distance from P to Q, either the left child or the right child or both of them are searched recursively. To return a fixed number of results, it suffices to implement the result list as a heap. In the concurrent filtering process, each node Q is examined against the filtering criteria before being added to the result list. In other words, points that cannot pass the filter remain in the index but cannot get into the result list. They preserve the functionality of providing links to their children.

This makes the algorithm more flexible than pre-query filtering since the same index can be used for any filtering criteria, which disables a different part of the tree. It is more efficient than post-query filtering as it searches for fewer data points, and it also returns exactly as many responses as we want.

For NSW, a similarity search without attribute filtering given query point P and number of neighbors k starts from finding the neighborhood of P. This is achieved by a Navigable-Small-World (NSW) graph that approximately connects every point with its neighbors. To find a point that is close to P, we simply use a greedy iterative approach: start from a random point, and choose the closest neighbor until we cannot get any closer. After obtaining a point Q that is close to P, we examine Q, Q's neighbors, Q's neighbors's neighbors, etc. and use a heap to record the k closest. The algorithm stops when increasing search radius cannot further improve the result set. As in VP-Tree, concurrent filtering means every point is examined before being allowed to enter the heap. Those invalid points remain in the index to connect the valid ones, but they are never considered to be part of the results.

The above argument about concurrent filtering for VP-Tree also stands for NSW. In fact, it is applicable for any kNN method that includes a stage of adding a potential response to a list. Following the same rationale, it can be inferred that concurrent filtering will be more effective than existing ones for hybrid searching on any similarity search algorithms with similar structure.
